var $c5594cadbeea03bc06cdcbed5a67e689$exports = {};
$parcel$require("c5594cadbeea03bc06cdcbed5a67e689", "react");
$parcel$require("c5594cadbeea03bc06cdcbed5a67e689", "react-dom");
var $c5594cadbeea03bc06cdcbed5a67e689$var$hadKeyboardEvent = true;
var $c5594cadbeea03bc06cdcbed5a67e689$var$hadFocusVisibleRecently = false;
var $c5594cadbeea03bc06cdcbed5a67e689$var$hadFocusVisibleRecentlyTimeout = null;
var $c5594cadbeea03bc06cdcbed5a67e689$var$inputTypesWhitelist = {
  text: true,
  search: true,
  url: true,
  tel: true,
  email: true,
  password: true,
  number: true,
  date: true,
  month: true,
  week: true,
  time: true,
  datetime: true,
  'datetime-local': true
};
/**
 * Computes whether the given element should automatically trigger the
 * `focus-visible` class being added, i.e. whether it should always match
 * `:focus-visible` when focused.
 * @param {Element} node
 * @return {boolean}
 */

function $c5594cadbeea03bc06cdcbed5a67e689$var$focusTriggersKeyboardModality(node) {
  var type = node.type,
      tagName = node.tagName;

  if (tagName === 'INPUT' && $c5594cadbeea03bc06cdcbed5a67e689$var$inputTypesWhitelist[type] && !node.readOnly) {
    return true;
  }

  if (tagName === 'TEXTAREA' && !node.readOnly) {
    return true;
  }

  if (node.isContentEditable) {
    return true;
  }

  return false;
}

function $c5594cadbeea03bc06cdcbed5a67e689$var$handleKeyDown() {
  $c5594cadbeea03bc06cdcbed5a67e689$var$hadKeyboardEvent = true;
}
/**
 * If at any point a user clicks with a pointing device, ensure that we change
 * the modality away from keyboard.
 * This avoids the situation where a user presses a key on an already focused
 * element, and then clicks on a different element, focusing it with a
 * pointing device, while we still think we're in keyboard modality.
 * @param {Event} e
 */


function $c5594cadbeea03bc06cdcbed5a67e689$var$handlePointerDown() {
  $c5594cadbeea03bc06cdcbed5a67e689$var$hadKeyboardEvent = false;
}

function $c5594cadbeea03bc06cdcbed5a67e689$var$handleVisibilityChange() {
  if (this.visibilityState === 'hidden') {
    // If the tab becomes active again, the browser will handle calling focus
    // on the element (Safari actually calls it twice).
    // If this tab change caused a blur on an element with focus-visible,
    // re-apply the class when the user switches back to the tab.
    if ($c5594cadbeea03bc06cdcbed5a67e689$var$hadFocusVisibleRecently) {
      $c5594cadbeea03bc06cdcbed5a67e689$var$hadKeyboardEvent = true;
    }
  }
}

function $c5594cadbeea03bc06cdcbed5a67e689$var$prepare(ownerDocument) {
  ownerDocument.addEventListener('keydown', $c5594cadbeea03bc06cdcbed5a67e689$var$handleKeyDown, true);
  ownerDocument.addEventListener('mousedown', $c5594cadbeea03bc06cdcbed5a67e689$var$handlePointerDown, true);
  ownerDocument.addEventListener('pointerdown', $c5594cadbeea03bc06cdcbed5a67e689$var$handlePointerDown, true);
  ownerDocument.addEventListener('touchstart', $c5594cadbeea03bc06cdcbed5a67e689$var$handlePointerDown, true);
  ownerDocument.addEventListener('visibilitychange', $c5594cadbeea03bc06cdcbed5a67e689$var$handleVisibilityChange, true);
}

function $c5594cadbeea03bc06cdcbed5a67e689$export$teardown(ownerDocument) {
  ownerDocument.removeEventListener('keydown', $c5594cadbeea03bc06cdcbed5a67e689$var$handleKeyDown, true);
  ownerDocument.removeEventListener('mousedown', $c5594cadbeea03bc06cdcbed5a67e689$var$handlePointerDown, true);
  ownerDocument.removeEventListener('pointerdown', $c5594cadbeea03bc06cdcbed5a67e689$var$handlePointerDown, true);
  ownerDocument.removeEventListener('touchstart', $c5594cadbeea03bc06cdcbed5a67e689$var$handlePointerDown, true);
  ownerDocument.removeEventListener('visibilitychange', $c5594cadbeea03bc06cdcbed5a67e689$var$handleVisibilityChange, true);
}

$c5594cadbeea03bc06cdcbed5a67e689$exports.teardown = $c5594cadbeea03bc06cdcbed5a67e689$export$teardown;

function $c5594cadbeea03bc06cdcbed5a67e689$var$isFocusVisible(event) {
  var target = event.target;

  try {
    return target.matches(':focus-visible');
  } catch (error) {} // browsers not implementing :focus-visible will throw a SyntaxError
  // we use our own heuristic for those browsers
  // rethrow might be better if it's not the expected error but do we really
  // want to crash if focus-visible malfunctioned?
  // no need for validFocusTarget check. the user does that by attaching it to
  // focusable events only


  return $c5594cadbeea03bc06cdcbed5a67e689$var$hadKeyboardEvent || $c5594cadbeea03bc06cdcbed5a67e689$var$focusTriggersKeyboardModality(target);
}
/**
 * Should be called if a blur event is fired on a focus-visible element
 */


function $c5594cadbeea03bc06cdcbed5a67e689$var$handleBlurVisible() {
  // To detect a tab/window switch, we look for a blur event followed
  // rapidly by a visibility change.
  // If we don't see a visibility change within 100ms, it's probably a
  // regular focus change.
  $c5594cadbeea03bc06cdcbed5a67e689$var$hadFocusVisibleRecently = true;
  window.clearTimeout($c5594cadbeea03bc06cdcbed5a67e689$var$hadFocusVisibleRecentlyTimeout);
  $c5594cadbeea03bc06cdcbed5a67e689$var$hadFocusVisibleRecentlyTimeout = window.setTimeout(function () {
    $c5594cadbeea03bc06cdcbed5a67e689$var$hadFocusVisibleRecently = false;
    window.clearTimeout($c5594cadbeea03bc06cdcbed5a67e689$var$hadFocusVisibleRecentlyTimeout);
  }, 100);
}

function $c5594cadbeea03bc06cdcbed5a67e689$export$useIsFocusVisible() {
  var ref = $c5594cadbeea03bc06cdcbed5a67e689$import$React.useCallback(function (instance) {
    var node = $c5594cadbeea03bc06cdcbed5a67e689$import$ReactDOM.findDOMNode(instance);

    if (node != null) {
      $c5594cadbeea03bc06cdcbed5a67e689$var$prepare(node.ownerDocument);
    }
  }, []);
  return {
    isFocusVisible: $c5594cadbeea03bc06cdcbed5a67e689$var$isFocusVisible,
    onBlurVisible: $c5594cadbeea03bc06cdcbed5a67e689$var$handleBlurVisible,
    ref: ref
  };
}

$c5594cadbeea03bc06cdcbed5a67e689$exports.useIsFocusVisible = $c5594cadbeea03bc06cdcbed5a67e689$export$useIsFocusVisible;