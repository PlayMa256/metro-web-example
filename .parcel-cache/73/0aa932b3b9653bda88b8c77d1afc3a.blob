var $ba5860437fe3dee2fd6652b92e74c$exports = {};
$parcel$require("811ba5860437fe3dee2fd6652b92e74c", "@babel/runtime/helpers/esm/extends");
$parcel$require("811ba5860437fe3dee2fd6652b92e74c", "@babel/runtime/helpers/esm/objectWithoutProperties");
$parcel$require("811ba5860437fe3dee2fd6652b92e74c", "react");
$parcel$require("811ba5860437fe3dee2fd6652b92e74c", "prop-types");
$parcel$require("811ba5860437fe3dee2fd6652b92e74c", "react-dom");
$parcel$require("811ba5860437fe3dee2fd6652b92e74c", "../utils/ownerDocument");
$parcel$require("811ba5860437fe3dee2fd6652b92e74c", "../List");
$parcel$require("811ba5860437fe3dee2fd6652b92e74c", "../utils/getScrollbarSize");
$parcel$require("811ba5860437fe3dee2fd6652b92e74c", "../utils/useForkRef");

function $ba5860437fe3dee2fd6652b92e74c$var$nextItem(list, item, disableListWrap) {
  if (list === item) {
    return list.firstChild;
  }

  if (item && item.nextElementSibling) {
    return item.nextElementSibling;
  }

  return disableListWrap ? null : list.firstChild;
}

function $ba5860437fe3dee2fd6652b92e74c$var$previousItem(list, item, disableListWrap) {
  if (list === item) {
    return disableListWrap ? list.firstChild : list.lastChild;
  }

  if (item && item.previousElementSibling) {
    return item.previousElementSibling;
  }

  return disableListWrap ? null : list.lastChild;
}

function $ba5860437fe3dee2fd6652b92e74c$var$textCriteriaMatches(nextFocus, textCriteria) {
  if (textCriteria === undefined) {
    return true;
  }

  var text = nextFocus.innerText;

  if (text === undefined) {
    // jsdom doesn't support innerText
    text = nextFocus.textContent;
  }

  if (text === undefined) {
    return false;
  }

  text = text.trim().toLowerCase();

  if (text.length === 0) {
    return false;
  }

  if (textCriteria.repeating) {
    return text[0] === textCriteria.keys[0];
  }

  return text.indexOf(textCriteria.keys.join('')) === 0;
}

function $ba5860437fe3dee2fd6652b92e74c$var$moveFocus(list, currentFocus, disableListWrap, traversalFunction, textCriteria) {
  var wrappedOnce = false;
  var nextFocus = traversalFunction(list, currentFocus, currentFocus ? disableListWrap : false);

  while (nextFocus) {
    // Prevent infinite loop.
    if (nextFocus === list.firstChild) {
      if (wrappedOnce) {
        return false;
      }

      wrappedOnce = true;
    } // Move to the next element.


    if (!nextFocus.hasAttribute('tabindex') || nextFocus.disabled || nextFocus.getAttribute('aria-disabled') === 'true' || !$ba5860437fe3dee2fd6652b92e74c$var$textCriteriaMatches(nextFocus, textCriteria)) {
      nextFocus = traversalFunction(list, nextFocus, disableListWrap);
    } else {
      nextFocus.focus();
      return true;
    }
  }

  return false;
}

var $ba5860437fe3dee2fd6652b92e74c$var$useEnhancedEffect = typeof window === 'undefined' ? $ba5860437fe3dee2fd6652b92e74c$import$React.useEffect : $ba5860437fe3dee2fd6652b92e74c$import$React.useLayoutEffect;
/**
 * A permanently displayed menu following https://www.w3.org/TR/wai-aria-practices/#menubutton
 * It's exposed to help customization of the [`Menu`](/api/menu/) component. If you
 * use it separately you need to move focus into the component manually. Once
 * the focus is placed inside the component it is fully keyboard accessible.
 */

var $ba5860437fe3dee2fd6652b92e74c$export$default = $ba5860437fe3dee2fd6652b92e74c$import$React.forwardRef(function MenuList(props, ref) {
  var actions = props.actions,
      _props$autoFocus = props.autoFocus,
      autoFocus = _props$autoFocus === void 0 ? false : _props$autoFocus,
      _props$autoFocusItem = props.autoFocusItem,
      autoFocusItem = _props$autoFocusItem === void 0 ? false : _props$autoFocusItem,
      children = props.children,
      className = props.className,
      onKeyDown = props.onKeyDown,
      _props$disableListWra = props.disableListWrap,
      disableListWrap = _props$disableListWra === void 0 ? false : _props$disableListWra,
      _props$variant = props.variant,
      variant = _props$variant === void 0 ? 'selectedMenu' : _props$variant,
      other = $ba5860437fe3dee2fd6652b92e74c$import$_objectWithoutProperties(props, ["actions", "autoFocus", "autoFocusItem", "children", "className", "onKeyDown", "disableListWrap", "variant"]);
  var listRef = $ba5860437fe3dee2fd6652b92e74c$import$React.useRef(null);
  var textCriteriaRef = $ba5860437fe3dee2fd6652b92e74c$import$React.useRef({
    keys: [],
    repeating: true,
    previousKeyMatched: true,
    lastTime: null
  });
  $ba5860437fe3dee2fd6652b92e74c$var$useEnhancedEffect(function () {
    if (autoFocus) {
      listRef.current.focus();
    }
  }, [autoFocus]);
  $ba5860437fe3dee2fd6652b92e74c$import$React.useImperativeHandle(actions, function () {
    return {
      adjustStyleForScrollbar: function adjustStyleForScrollbar(containerElement, theme) {
        // Let's ignore that piece of logic if users are already overriding the width
        // of the menu.
        var noExplicitWidth = !listRef.current.style.width;

        if (containerElement.clientHeight < listRef.current.clientHeight && noExplicitWidth) {
          var scrollbarSize = "".concat($ba5860437fe3dee2fd6652b92e74c$import$getScrollbarSize(true), "px");
          listRef.current.style[theme.direction === 'rtl' ? 'paddingLeft' : 'paddingRight'] = scrollbarSize;
          listRef.current.style.width = "calc(100% + ".concat(scrollbarSize, ")");
        }

        return listRef.current;
      }
    };
  }, []);

  var handleKeyDown = function handleKeyDown(event) {
    var list = listRef.current;
    var key = event.key;
    /**
     * @type {Element} - will always be defined since we are in a keydown handler
     * attached to an element. A keydown event is either dispatched to the activeElement
     * or document.body or document.documentElement. Only the first case will
     * trigger this specific handler.
     */

    var currentFocus = $ba5860437fe3dee2fd6652b92e74c$import$ownerDocument(list).activeElement;

    if (key === 'ArrowDown') {
      event.preventDefault();
      $ba5860437fe3dee2fd6652b92e74c$var$moveFocus(list, currentFocus, disableListWrap, $ba5860437fe3dee2fd6652b92e74c$var$nextItem);
    } else if (key === 'ArrowUp') {
      event.preventDefault();
      $ba5860437fe3dee2fd6652b92e74c$var$moveFocus(list, currentFocus, disableListWrap, $ba5860437fe3dee2fd6652b92e74c$var$previousItem);
    } else if (key === 'Home') {
      event.preventDefault();
      $ba5860437fe3dee2fd6652b92e74c$var$moveFocus(list, null, disableListWrap, $ba5860437fe3dee2fd6652b92e74c$var$nextItem);
    } else if (key === 'End') {
      event.preventDefault();
      $ba5860437fe3dee2fd6652b92e74c$var$moveFocus(list, null, disableListWrap, $ba5860437fe3dee2fd6652b92e74c$var$previousItem);
    } else if (key.length === 1) {
      var criteria = textCriteriaRef.current;
      var lowerKey = key.toLowerCase();
      var currTime = performance.now();

      if (criteria.keys.length > 0) {
        // Reset
        if (currTime - criteria.lastTime > 500) {
          criteria.keys = [];
          criteria.repeating = true;
          criteria.previousKeyMatched = true;
        } else if (criteria.repeating && lowerKey !== criteria.keys[0]) {
          criteria.repeating = false;
        }
      }

      criteria.lastTime = currTime;
      criteria.keys.push(lowerKey);
      var keepFocusOnCurrent = currentFocus && !criteria.repeating && $ba5860437fe3dee2fd6652b92e74c$var$textCriteriaMatches(currentFocus, criteria);

      if (criteria.previousKeyMatched && (keepFocusOnCurrent || $ba5860437fe3dee2fd6652b92e74c$var$moveFocus(list, currentFocus, false, $ba5860437fe3dee2fd6652b92e74c$var$nextItem, criteria))) {
        event.preventDefault();
      } else {
        criteria.previousKeyMatched = false;
      }
    }

    if (onKeyDown) {
      onKeyDown(event);
    }
  };

  var handleOwnRef = $ba5860437fe3dee2fd6652b92e74c$import$React.useCallback(function (instance) {
    // #StrictMode ready
    listRef.current = $ba5860437fe3dee2fd6652b92e74c$import$ReactDOM.findDOMNode(instance);
  }, []);
  var handleRef = $ba5860437fe3dee2fd6652b92e74c$import$useForkRef(handleOwnRef, ref);
  /**
   * the index of the item should receive focus
   * in a `variant="selectedMenu"` it's the first `selected` item
   * otherwise it's the very first item.
   */

  var activeItemIndex = -1; // since we inject focus related props into children we have to do a lookahead
  // to check if there is a `selected` item. We're looking for the last `selected`
  // item and use the first valid item as a fallback

  $ba5860437fe3dee2fd6652b92e74c$import$React.Children.forEach(children, function (child, index) {
    if (!$ba5860437fe3dee2fd6652b92e74c$import$React.isValidElement(child)) {
      return;
    }

    if ("production" !== 'production') {
      if (child.type === $ba5860437fe3dee2fd6652b92e74c$import$React.Fragment) {
        console.error(["Material-UI: the Menu component doesn't accept a Fragment as a child.", 'Consider providing an array instead.'].join('\n'));
      }
    }

    if (!child.props.disabled) {
      if (variant === 'selectedMenu' && child.props.selected) {
        activeItemIndex = index;
      } else if (activeItemIndex === -1) {
        activeItemIndex = index;
      }
    }
  });
  var items = $ba5860437fe3dee2fd6652b92e74c$import$React.Children.map(children, function (child, index) {
    if (index === activeItemIndex) {
      var newChildProps = {};

      if (autoFocusItem) {
        newChildProps.autoFocus = true;
      }

      if (child.props.tabIndex === undefined && variant === 'selectedMenu') {
        newChildProps.tabIndex = 0;
      }

      if (newChildProps !== null) {
        return $ba5860437fe3dee2fd6652b92e74c$import$React.cloneElement(child, newChildProps);
      }
    }

    return child;
  });
  return $ba5860437fe3dee2fd6652b92e74c$import$React.createElement($ba5860437fe3dee2fd6652b92e74c$import$List, $ba5860437fe3dee2fd6652b92e74c$import$_extends({
    role: "menu",
    ref: handleRef,
    className: className,
    onKeyDown: handleKeyDown,
    tabIndex: autoFocus ? 0 : -1
  }, other), items);
});
"production" !== "production" ? $ba5860437fe3dee2fd6652b92e74c$export$default.propTypes = {
  /**
   * @ignore
   */
  actions: $ba5860437fe3dee2fd6652b92e74c$import$PropTypes.shape({
    current: $ba5860437fe3dee2fd6652b92e74c$import$PropTypes.object
  }),

  /**
   * If `true`, will focus the `[role="menu"]` container and move into tab order
   */
  autoFocus: $ba5860437fe3dee2fd6652b92e74c$import$PropTypes.bool,

  /**
   * If `true`, will focus the first menuitem if `variant="menu"` or selected item
   * if `variant="selectedMenu"`
   */
  autoFocusItem: $ba5860437fe3dee2fd6652b92e74c$import$PropTypes.bool,

  /**
   * MenuList contents, normally `MenuItem`s.
   */
  children: $ba5860437fe3dee2fd6652b92e74c$import$PropTypes.node,

  /**
   * @ignore
   */
  className: $ba5860437fe3dee2fd6652b92e74c$import$PropTypes.string,

  /**
   * If `true`, the menu items will not wrap focus.
   */
  disableListWrap: $ba5860437fe3dee2fd6652b92e74c$import$PropTypes.bool,

  /**
   * @ignore
   */
  onKeyDown: $ba5860437fe3dee2fd6652b92e74c$import$PropTypes.func,

  /**
   * The variant to use. Use `menu` to prevent selected items from impacting the initial focus
   * and the vertical alignment relative to the anchor element.
   */
  variant: $ba5860437fe3dee2fd6652b92e74c$import$PropTypes.oneOf(['menu', 'selectedMenu'])
} : void 0;
$ba5860437fe3dee2fd6652b92e74c$exports.default = $ba5860437fe3dee2fd6652b92e74c$export$default;